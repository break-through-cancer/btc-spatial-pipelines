---
title: "BTC CytAssist Pilot"
author: "LTKAGOHARA"
date: "2024-12-04"
output:
  html_document: default
  pdf_document: default
---

# VISIUM DATA ANALYSIS WITH SEURAT
# Incorporating CODA for cell type annotations

##### Loading packages
```{r}
library(Seurat)
library(ggplot2)
library(leiden)
library(patchwork)
library(dplyr)
library(rhdf5)
library(ggrepel)
library(Rfast2)
library(EnhancedVolcano)
library(fgsea)
library(msigdbr)
library(RColorBrewer)
library(ggpubr)
```

## Increasing the allowed memory to avoid errors regarding lack of memory
```{r}
options(future.globals.maxSize = 1024 * 1024 * 1024)  # 1 GB
```

## Loading the data for sample BTC13
```{r}
BTC13 <- Load10X_Spatial("BTC13/")
dim(BTC13)
head(BTC13@meta.data)
```

## INTEGRATING CODA CELL CLASSIFICATION INTO METADATA
```{r}
# extract BTC13 metadata
BTC13metadata <- BTC13@meta.data

# uploading CODA annotations
codaBTC13 <- as.data.frame(read.csv("tissue_positions_cellular_compositions.csv"))
rownames(codaBTC13) <- codaBTC13$X
codaBTC13 <- codaBTC13[, -c(1, 2, 3, 4, 5, 6)]
head(codaBTC13)

# merging CODA annotations to metadata
BTC13metadata <- merge(BTC13metadata, codaBTC13, by = "row.names")

# assigning cell types from CODA quantifications per spot (barcode)
BTC13metadata$CODA <- "mixed"
BTC13metadata$CODA[BTC13metadata$RespondingPDAC > 51] <- "responding"
BTC13metadata$CODA[BTC13metadata$NonrespondingPDAC > 51] <- "non-responding"
BTC13metadata$CODA[BTC13metadata$Stroma > 51] <- "stroma"
BTC13metadata$CODA[BTC13metadata$Immune > 51] <- "immune"
BTC13metadata$CODA[BTC13metadata$Vasculature > 51] <- "vasculature"
BTC13metadata$CODA[BTC13metadata$Fat > 51] <- "fat"
BTC13metadata$CODA[BTC13metadata$Acini > 51] <- "acini"
BTC13metadata$CODA[BTC13metadata$Islets > 51] <- "islets"
BTC13metadata$CODA[BTC13metadata$Nerve > 51] <- "nerve"
BTC13metadata$CODA[BTC13metadata$Duct > 51] <- "normal duct"
BTC13metadata$CODA[BTC13metadata$RespondingPDAC == 0 & 
                 BTC13metadata$NonrespondingPDAC == 0 & 
                 BTC13metadata$Stroma == 0 & 
                 BTC13metadata$Immune == 0 &
                 BTC13metadata$Vasculature == 0 &
                 BTC13metadata$Fat == 0 &
                 BTC13metadata$Acini == 0 &
                 BTC13metadata$Islets == 0 &
                 BTC13metadata$Nerve == 0 &
                 BTC13metadata$Duct == 0] <- "NA"
table(BTC13metadata$CODA)

BTC13 <- AddMetaData(object = BTC13, metadata = BTC13metadata)
head(BTC13)
```

##### saving object with CODA classification
```{r}
save(BTC13, file = "BTC13_CODA.Rda")
```

# DATA PREPROCESSING

## QC and filtering
```{r}
load("BTC13_CODA.Rda")

# proportion of mitochondrial reads
BTC13[["percent_mt"]] <- PercentageFeatureSet(BTC13, pattern = "^MT-")
head(BTC13@meta.data)

VlnPlot(BTC13, features = c("nFeature_Spatial", "nCount_Spatial", "percent_mt"), ncol = 3)
ggsave("BTC13_QC1.png")

plot1 <- FeatureScatter(BTC13, feature1 = "nCount_Spatial", feature2 = "percent_mt")
plot2 <- FeatureScatter(BTC13, feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial")
wrap_plots(plot1, plot2)
ggsave("BTC13_QC2.png")

# plots to verify the variance in counts across spots
plot3 <- VlnPlot(BTC13, features = "nCount_Spatial", pt.size = 0.1) + NoLegend()
plot4 <- SpatialFeaturePlot(BTC13, features = "nCount_Spatial", pt.size.factor = 7) + theme(legend.position = "right")
wrap_plots(plot3, plot4)
ggsave("BTC13_QC3.png")

# NOTE: data looks good quality and spots were not filtered out of the analysis
```

##### saving filtered dataset
```{r}
save(BTC13, file = "BTC13_filtered.Rda")
```

## NORMALIZATION WITH SCTransform
```{r}
load("BTC13_filtered.Rda")

BTC13 <- SCTransform(BTC13, assay = "Spatial", vars.to.regress = "percent_mt",verbose = F)
```

##### saving SCTransformed data
```{r}
save(BTC13, file = "BTC13_SCTransformed.Rda")
```

## DIMENSIONALITY REDUCTION, CLUSTERING, VISUALIZATION
```{r}
load("BTC13_SCTransformed.Rda")

BTC13 <- RunPCA(BTC13, assay = "SCT")
DimPlot(BTC13, reduction = "pca")

# cluster spots
BTC13 <- FindNeighbors(BTC13, reduction = "pca", dims = 1:30)
BTC13 <- FindClusters(BTC13, algorithm = 4)

# run UMAP for dimensional reduction
BTC13 <- RunUMAP(BTC13, reduction = "pca", dims = 1:30)

# creating a palette of colors that fits 15 clusters
colorcount <- length(unique(BTC13$SCT_snn_res.0.8))
myPalette <- colorRampPalette(brewer.pal(12, "Paired"))

DimPlot(BTC13, reduction = "umap", label = TRUE)
ggsave("BTC13_Dimplot.png")
SpatialDimPlot(BTC13, label = T, label.size = 2.5, pt.size.factor = 7) + 
  scale_fill_manual(values = myPalette(colorcount))
ggsave("BTC13_clustering_res08.png")

# highligthing specific clusters (cluster by cluster plot)
# all clusters
SpatialDimPlot(BTC13, 
               cells.highlight = CellsByIdentities(object = BTC13,idents = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
                                                                             11, 12, 13, 14, 15, 16, 17)),
               facet.highlight = T, ncol = 6, pt.size.factor = 7, image.alpha = 1, alpha = 0.5)

ggsave("BTC13_cluster_highlights_res08.png")
```

##### saving reduced data
```{R}
save(BTC13, file = "BTC13_clustered.Rda")
```

## FINDING CLUSTER MARKER GENES
```{r}
load("BTC13_clustered.Rda")

### find all markers in each cluster distinguishing one cluster from all other spots
markers_BTC13 <- FindAllMarkers(BTC13, test.use = "MAST",only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)
markers_df <- as.data.frame(markers_BTC13 %>% group_by(cluster) %>% slice_max(n = 10, order_by = avg_log2FC))
DoHeatmap(BTC13,features = markers_df$gene)
ggsave("BTC13_markersHM.png")
```

## INDENTIFYING HIGHLY VARIABLE SPATIAL FEATURES
```{r}
# FindSpatiallyVariables search for features without pre-annotation
# "markvariogram" finds genes whose expression depends on spatial location
BTC13 <- FindVariableFeatures(BTC13, selection.method = "vst", nfeatures = 2000)
topBTC13_varfeat <- head(VariableFeatures(BTC13), 10)
topBTC13_varfeat

BTC13 <- FindSpatiallyVariableFeatures(BTC13, assay = "SCT", 
                                     features = VariableFeatures(BTC13)[1:2000], 
                                     selection.method = "moransi")
top_features <- head(VariableFeatures(BTC13, method = "moransi"), 20)
SpatialFeaturePlot(BTC13, features = top_features, ncol = 5, alpha = c(0.1,1))
ggsave("BTC13_varfeatures.png")
```

##### saving variable features data
```{r}
save(BTC13, file = "BTC13_VarFeatures.Rda")
```

## SETTING CODA AS ACTIVE IDENTITIES
```{r}
load("BTC13_VarFeatures.Rda")

# making CODA annotations the active identities
Idents(BTC13) <- "CODA"
table(Idents(BTC13))

SpatialDimPlot(BTC13, label = T, label.size = 2.5, pt.size.factor = 5, cols = "Paired")
ggsave("BTC13_clustering_CODA.png")

SpatialDimPlot(BTC13, 
               cells.highlight = CellsByIdentities(object = BTC13,idents = c("responding", "non-responding", "stroma", 
                                                                             "immune", "vasculature",  "fat", "acini", 
                                                                             "islets", "nerve", "normal duct", "mixed")),
               facet.highlight = T, ncol = 6, pt.size.factor = 7, image.alpha = 1, alpha = 0.5)

ggsave("BTC13_cluster_highlights_CODA.png")

markers_BTC13 <- FindAllMarkers(BTC13, test.use = "MAST",only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)
codamarkers_df <- as.data.frame(markers_BTC13 %>% group_by(cluster) %>% slice_max(n = 10, order_by = avg_log2FC))
DoHeatmap(BTC13,features = codamarkers_df$gene)
ggsave("BTC13_markersHM_CODA.png")
```

##### saving the object using the CODA annotations as active idents
```{r}
save(BTC13, file = "BTC13_CODAidents.Rda")
```

## Differential expression analysis with CODA annotations
```{r}
load("BTC13_CODAidents.Rda")

DGEA <- FindMarkers(BTC13, test.use = "MAST", ident.1 = "responding", ident.2 = "non-responding", logfc.treshold = 0.1, min.pct = 0.1)
dgea_df <- as.data.frame(DGEA)

top_genes <- rownames(DGEA)[order(DGEA$p_val_adj)][1:10]

EnhancedVolcano(dgea_df, 
                lab = rownames(dgea_df), 
                x = 'avg_log2FC', 
                y = 'p_val',
                title = 'responding vs. non-responding',
                pCutoff = 1e-2,
                FCcutoff = 1,
                pointSize = 0.5,
                xlim = c(-1.5, 1.5), 
                ylim = c(0, 5), 
                labSize = 4.0)
ggsave("BTC13_DGEA_volcano.png")
write.csv(dgea_df, file = "BTC13_DGEA_output.csv")

# GSEA
# ranking genes
ranks <- dgea_df$avg_log2FC
names(ranks) <- rownames(dgea_df)
head(ranks)
ranks <- sort(ranks, decreasing = TRUE) # sorting genes by ranking
plot(ranks)

# loading MSigDB Hallmark pathways for mouse
hs_df = msigdbr(species = "Homo sapiens", category = "H")

# converting to list format
hs_list = hs_df %>% split(x = .$gene_symbol, f = .$gs_name)

# Show the first few pathways, and within those, show only the first few genes. 
hs_list %>% 
  head() %>% 
  lapply(head)

# running fgsea
fgseaRes <- fgseaMultilevel(pathways = hs_list, 
                            stats = ranks, 
                            scoreType = "std", 
                            nPermSimple = 10000, 
                            nproc = 1)
head(fgseaRes)
save(fgseaRes, file = "BTC13_fgsea_hallmarks.Rda")

ggplot(fgseaRes, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=pval<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme_minimal()
ggsave("BTC13_GSEA_NES_waterfall.png")
```


## Identifying PDAC transcriptional subtypes
```{r}
### AddModuleScore for PDAC subtypes (Moffitt classification - classical and basal-like)

load("BTC13_CODAidents.Rda")

# subsetting for epithelial cells
BTC13epit <- subset(BTC13, idents = c("responding", "non-responding", "normal duct"))
SpatialDimPlot(BTC13epit, label = T, label.size = 2.5, pt.size.factor = 5, cols = "Paired")

save(BTC13epit, file = "BTC13_Epithelial.Rda")

# PDAC basal subtype
basal_genes <- list(c('VGLL','UCA1','S100A2','LY6D','SPRR3','SPRR1B','LEMD1','KRT15',
                      'CTSL2','DHRS9','AREG','CST6','SERPINB3','KRT6C','KRT6A','SERPINB4',
                      'FAM83A','SCEL','FGFBP1','KRT7','KRT17','GPR87','TNS4','SLC2A1',
                      'ANXA8L2'))
BTC13epit <- AddModuleScore(BTC13epit, features = basal_genes, name = 'basal')
SpatialFeaturePlot(BTC13epit, features = 'basal1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_basal.png")

VlnPlot(BTC13epit, features = 'basal1')
ggsave("BTC13_basal_vln.png")

# PDAC classical subtype
classical_genes <- list(c('BTNL8','FAM3D','ATAD4','AGR3','CTSE','LOC400573','LYZ','TFF2',
                          'TFF1','ANXA10','LGALS4','PLA2G10','CEACAM6','VSIG2','TSPAN8',
                          'ST6GALNAC1','AGR2','TFF3','CYP3A7','MYO1A','CLRN3','KRT20',
                          'CDH17','SPINK4','REG4'))
BTC13epit <- AddModuleScore(BTC13epit, features = classical_genes, name = 'classical')
SpatialFeaturePlot(BTC13epit, features = 'classical1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_classical.png")

VlnPlot(BTC13epit, features = 'classical1')
ggsave("BTC13_classical_vln.png")
```

## Identifying CAF subtypes
```{r}
### AddModuleScore for CAF subtypes

load("BTC13_CODAidents.Rda")

# subsetting for stroma
BTC13stroma <- subset(BTC13, idents = "stroma")
save(BTC13stroma, file = "BTC13_Stroma.Rda")

# panCAFs
pancaf_genes <- list(c('LUM','DCN','COL1A1','VIM','CD39','FSP1','FAP','ACTA2','PDPN'))
BTC13stroma <- AddModuleScore(BTC13stroma, features = pancaf_genes, name = 'panCAF')
SpatialFeaturePlot(BTC13stroma, features = 'panCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_panCAF.png")

# iCAFs
iCAF_genes <- list(c('CXCL1','CXCL2','CCL2','CXCL12','PDGFRA','CFD','LMNA','DPT','HAS1','HAS2'))
BTC13stroma <- AddModuleScore(BTC13stroma, features = iCAF_genes, name = 'iCAF')
SpatialFeaturePlot(BTC13stroma, features = 'iCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_iCAF.png")

# myCAFs
myCAF_genes <- list(c('TAGLN','MYL9','TPM2','MMP11','POSTN','HOPX','TWIST1','SOX4'))
BTC13stroma <- AddModuleScore(BTC13stroma, features = myCAF_genes, name = 'myCAF')
SpatialFeaturePlot(BTC13stroma, features = 'myCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_myCAF.png")

# apCAFs
apCAF_genes <- list(c('HLA-DRA','HLA-DPA1','CD74','HLA-DQ','SLPI'))
BTC13stroma <- AddModuleScore(BTC13stroma, features = apCAF_genes, name = 'apCAF')
SpatialFeaturePlot(BTC13stroma, features = 'apCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC13_apCAF.png")
```

### Module score analysis for Hallmark Pathways for Epithelial (responding, non-responding, normal) Cells
```{r}
load("BTC13_Epithelial.Rda")

# loading and create a list of MSigDB Hallmark pathways
hallmark_pathways = msigdbr(species = "Homo sapiens", category = "H")
hallmark_list <- split(hallmark_pathways$gene_symbol, hallmark_pathways$gs_name)

# directory to save the plots
output_dir <- "Analysis_pilot/BTC13/"
dir.create(output_dir, showWarnings = FALSE)

# loop for calculating module scores
for (pathway in names(hallmark_list)) {
  BTC13epit <- AddModuleScore(
    object = BTC13epit,
    features = list(hallmark_list[[pathway]]),
    name = pathway,
    ctrl = 5
  )
  
  # Plot the SpatialFeaturePlot
    plot <- SpatialFeaturePlot(BTC13epit, features = paste0(pathway, "1"))
    print(plot)
  
  # Save the plot
    ggsave(filename = file.path(output_dir, paste0(pathway, "_feature_plot.png")), plot = p, width = 8, height = 6)
}

head(BTC13epit@meta.data)

save(BTC13epit, file = 'Analysis_pilot/BTC13epit_modscores.Rda')
```

### module scores violin plots
```{r}
# subsetting data for violin plots
epit_meta <- BTC13epit@meta.data

# creating groups for statistical comparisons
mycomparisons <- list(c('normal duct','responding'), c('normal duct','non-responding'), c('responding','non-responding'))

# loop for module scores
for (pathway in names(hallmark_list)) {
  pathway_name <- paste0(pathway, "1")
  
  # Check if the pathway score exists in the metadata
  if (pathway_name %in% colnames(epit_meta)) {
    p <- ggplot(epit_meta, aes(x = CODA, y = .data[[pathway_name]])) + 
      geom_violin(aes(fill = CODA)) +
      geom_jitter(shape = 16, position = position_jitter(0.2)) +
      scale_x_discrete(name = 'Cell Type', limits = c("normal duct", "responding", "non-responding")) + 
      stat_compare_means(comparisons = mycomparisons) +
      ggtitle(pathway)
    
    # Save the plot
    ggsave(filename = file.path(output_dir, paste0(pathway, "_violin_plot.png")), plot = p, width = 8, height = 6)
    
    print(p)
  
  }
}
```

## Incorporating the epithelial and CAF module scores into the complete Seurat object
```{r}

```

